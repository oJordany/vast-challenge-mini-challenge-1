<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Oceanus Folk Influence Network - Task 2(b)</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Source+Serif+4:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <style>
      :root {
        --bg: #0b1220;
        --panel: #101826;
        --card: #f8fafc;
        --ink: #0f172a;
        --muted: #64748b;
        --accent: #f97316;
        --accent-2: #06b6d4;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Source Serif 4", serif;
        background:
          radial-gradient(circle at 15% 10%, rgba(249,115,22,0.18), transparent 40%),
          radial-gradient(circle at 85% 20%, rgba(6,182,212,0.18), transparent 45%),
          radial-gradient(circle at 50% 80%, rgba(148,163,184,0.15), transparent 50%),
          var(--bg);
        color: #e2e8f0;
      }

      .shell {
        max-width: 96vw;
        margin: 0 auto;
        padding: 28px 20px 40px;
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      header.hero {
        display: grid;
        gap: 14px;
        padding: 24px 26px;
        border-radius: 18px;
        background: linear-gradient(120deg, rgba(15,23,42,0.9), rgba(30,41,59,0.92));
        border: 1px solid rgba(148,163,184,0.25);
        box-shadow: 0 24px 50px rgba(2,8,23,0.45);
      }

      .hero h1 {
        margin: 0;
        font-family: "Space Grotesk", sans-serif;
        font-size: 28px;
        letter-spacing: 0.4px;
      }

      .hero p {
        margin: 0;
        color: #cbd5f5;
        max-width: 900px;
        line-height: 1.6;
      }

      .kpis {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px;
      }

      .kpi {
        padding: 14px 16px;
        border-radius: 14px;
        background: rgba(15,23,42,0.65);
        border: 1px solid rgba(148,163,184,0.25);
      }

      .kpi span.label {
        display: block;
        font-family: "Space Grotesk", sans-serif;
        font-size: 12px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: #94a3b8;
        margin-bottom: 6px;
      }

      .kpi span.value {
        display: block;
        font-family: "Space Grotesk", sans-serif;
        font-size: 20px;
        color: #f8fafc;
      }

      .kpi span.meta {
        display: block;
        font-size: 12px;
        color: #94a3b8;
        margin-top: 4px;
      }

      section.panel {
        background: var(--card);
        color: var(--ink);
        border-radius: 18px;
        padding: 18px 18px 8px;
        box-shadow: 0 24px 48px rgba(2, 8, 23, 0.35);
      }

      .panel h2 {
        margin: 0 0 6px;
        font-family: "Space Grotesk", sans-serif;
        font-size: 18px;
      }

      .panel p {
        margin: 0 0 10px;
        color: var(--muted);
        font-size: 13px;
      }

      .network-grid {
        display: grid;
        grid-template-columns: minmax(0, 1fr) 360px;
        gap: 16px;
        align-items: stretch;
      }

      .chart-wrap {
        padding: 8px 8px 12px;
        border-radius: 16px;
        background: #f8fafc;
        width: 100%;
        height: 70vh;
        max-height: 680px;
        min-height: 460px;
      }

      #chart {
        width: 100%;
        height: 100%;
      }

      #bar-chart {
        width: 100%;
        height: 100%;
      }

      .ranking-section {
        flex: 2 1 0;
        min-height: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .ranking-grid {
        display: grid;
        grid-template-columns: 1.2fr 1fr;
        gap: 10px;
        align-items: stretch;
        flex: 1 1 0;
        min-height: 0;
        margin-bottom: 8px;
      }

      .ranking-chart {
        width: 100%;
        height: 100%;
        min-height: 0;
      }

      .side-panel {
        border-radius: 16px;
        background: #f8fafc;
        padding: 12px 14px;
        border: 1px solid #e2e8f0;
        display: flex;
        flex-direction: column;
        gap: 10px;
        height: 100%;
        min-height: 0;
      }

      .side-panel h3 {
        margin: 0;
        font-family: "Space Grotesk", sans-serif;
        font-size: 14px;
        color: #0f172a;
      }

      .side-panel ol {
        margin: 0;
        padding-left: 18px;
        font-size: 12px;
        color: #334155;
      }

      .artist-list {
        height: 100%;
        overflow-y: auto;
      }

      .artist-details {
        border-top: 1px dashed #e2e8f0;
        padding-top: 10px;
        font-size: 12px;
        color: #334155;
        flex: 1 1 0;
        min-height: 0;
        overflow-y: auto;
      }

      .artist-details h4 {
        margin: 0 0 6px;
        font-family: "Space Grotesk", sans-serif;
        color: #0f172a;
      }

      .detail-row {
        margin-bottom: 4px;
      }

      .artist-list li.active {
        background: #e2e8f0;
        border-radius: 6px;
        padding: 2px 4px;
      }

      .side-panel li {
        margin-bottom: 6px;
      }

      .side-panel button {
        background: none;
        border: none;
        color: #0f172a;
        font-family: "Space Grotesk", sans-serif;
        font-size: 12px;
        text-align: left;
        cursor: pointer;
        padding: 0;
      }

      .side-panel button:hover {
        color: #2563eb;
      }

      .hint {
        font-size: 12px;
        color: #64748b;
        margin-top: 8px;
      }

      .legend {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 8px;
        font-size: 12px;
        color: #64748b;
      }

      .legend-row {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 8px;
      }

      .legend-title {
        display: block;
        font-family: "Space Grotesk", sans-serif;
        font-size: 11px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #94a3b8;
        margin-bottom: 4px;
      }

      .legend-item {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        padding: 2px 6px;
        border-radius: 999px;
        border: 1px solid transparent;
      }

      .legend-item.active {
        border-color: #94a3b8;
        background: #e2e8f0;
        color: #0f172a;
      }

      .legend-item.is-hover {
        border-color: #2563eb;
        box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
        color: #0f172a;
      }

      .legend-swatch {
        width: 12px;
        height: 12px;
        display: inline-block;
      }

      .legend-diamond {
        transform: rotate(45deg);
        border-radius: 2px;
      }

      .legend-circle {
        border-radius: 999px;
        border: 1.5px solid #0f172a;
        background: #e2e8f0;
      }

      .legend-roundrect {
        border-radius: 3px;
        border: 1.5px solid #ffffff;
      }

      .legend-hint {
        font-size: 11px;
        color: #94a3b8;
        margin-top: 2px;
      }

      .footnote {
        margin: 8px 0 0;
        font-size: 12px;
        color: #64748b;
      }

      @media (max-width: 1000px) {
        .network-grid {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 900px) {
        .hero h1 {
          font-size: 22px;
        }
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <header class="hero">
        <h1>Influence Map: Genres + Artists</h1>
        <p>
          This network highlights which genre families and artists are most impacted by Oceanus Folk. Node size
          reflects influence volume, and edges encode the flow from Oceanus Folk to genres and onward to creators.
        </p>
        <div class="kpis">
          <div class="kpi">
            <span class="label">Influenced works</span>
            <span class="value" id="kpi-works">__KPI_WORKS__</span>
            <span class="meta">Unique works in scope</span>
          </div>
          <div class="kpi">
            <span class="label">Influenced artists</span>
            <span class="value" id="kpi-artists">__KPI_ARTISTS__</span>
            <span class="meta">Artists with ≥3 roles</span>
          </div>
          <div class="kpi">
            <span class="label">Top genre</span>
            <span class="value" id="kpi-top-genre">__KPI_TOP_GENRE__</span>
            <span class="meta">By unique works</span>
          </div>
          <div class="kpi">
            <span class="label">Top artist</span>
            <span class="value" id="kpi-top-artist">__KPI_TOP_ARTIST__</span>
            <span class="meta">By total roles</span>
          </div>
        </div>
      </header>

      <section class="panel">
        <h2>Influence Network</h2>
        <p>
          Drag nodes to re-layout. Hover any node for detailed role breakdowns. Use the list to jump to a top artist.
        </p>
        <div class="legend">
          <div class="legend-block">
            <span class="legend-title">Node types</span>
            <div class="legend-row">
              <div class="legend-item legend-static" data-type="oceanus">
                <span class="legend-swatch legend-roundrect" style="background:#111827"></span>
                Oceanus Folk
              </div>
              <div class="legend-item legend-static" data-type="genre">
                <span class="legend-swatch legend-diamond" style="background:#3b82f6"></span>
                Genre
              </div>
              <div class="legend-item legend-static" data-type="artist">
                <span class="legend-swatch legend-circle"></span>
                Artist
              </div>
            </div>
            <div class="legend-hint">Size encodes influence volume.</div>
          </div>
          <div class="legend-block">
            <span class="legend-title">Genre palette</span>
            <div class="legend-row" id="genre-legend"></div>
            <div class="legend-hint">Shift + right-click to multi-select genres.</div>
          </div>
        </div>
        <div class="network-grid">
          <div class="chart-wrap">
            <div id="chart"></div>
          </div>
          <aside class="side-panel">
            <h3 id="artist-rank-title">Artist ranking (all)</h3>
            <div class="ranking-section">
              <div class="ranking-grid">
                <ol id="top-artists" class="artist-list"></ol>
                <div id="bar-chart" class="ranking-chart"></div>
              </div>
              <div class="hint">Use the slider to scroll the full ranking. Click a bar or name to focus.</div>
            </div>
            <div id="artist-details" class="artist-details">
              <em>Select an artist to see full credits.</em>
            </div>
          </aside>
        </div>
        <p class="footnote">
          Method: artists are connected via Performer, Composer, Producer, and Lyricist roles on works influenced
          by Oceanus Folk. Only artists with three or more role entries are shown in the network. Click a genre node
          to isolate its artists; click again or the background to reset.
        </p>
      </section>
    </div>

    <script>
      const payload = __DATA__;
      const allNodes = payload.nodes;
      const allLinks = payload.links;
      const artistRanking = payload.artistRanking || payload.topArtists || [];
      const artistDetails = payload.artistDetails || {};
      const artistTotals = payload.artistTotals || {};
      const artistGenreCounts = payload.artistGenreCounts || {};
      const kpiDefault = payload.kpis || {};

      const chart = echarts.init(document.getElementById("chart"));
      const barChart = echarts.init(document.getElementById("bar-chart"));

      let selectedGenres = new Set();
      let currentNodes = allNodes;
      let currentLinks = allLinks;
      let currentRanking = [];
      let currentRankingNames = [];
      let currentVisibleRanking = [];

      const baseGraphOption = {
        backgroundColor: "transparent",
        tooltip: {
          trigger: "item",
          backgroundColor: "rgba(15,23,42,0.95)",
          borderColor: "rgba(148,163,184,0.4)",
          borderWidth: 1,
          textStyle: {
            color: "#f8fafc",
            fontFamily: "Space Grotesk",
            fontSize: 12
          },
          extraCssText: "border-radius:10px; box-shadow:0 12px 24px rgba(15,23,42,0.25);",
          formatter: (params) => {
            if (params.dataType === "edge") {
              return `${params.data.source} → ${params.data.target}<br/>Influence: ${params.data.value}`;
            }
            return params.data.tooltip || params.name;
          }
        },
        series: [
          {
            type: "graph",
            layout: "force",
            data: currentNodes,
            links: currentLinks,
            categories: [
              { name: "Oceanus Folk" },
              { name: "Genre" },
              { name: "Artist" }
            ],
            roam: true,
            draggable: true,
            lineStyle: {
              color: "source",
              curveness: 0.28,
              width: 1.2
            },
            label: {
              show: true,
              fontFamily: "Space Grotesk",
              color: "#0f172a"
            },
            emphasis: {
              focus: "adjacency",
              lineStyle: {
                width: 3,
                opacity: 0.8
              }
            },
            force: {
              repulsion: 300,
              edgeLength: [70, 220],
              gravity: 0.08
            }
          }
        ]
      };

      chart.setOption(baseGraphOption);

      const listEl = document.getElementById("top-artists");
      const detailEl = document.getElementById("artist-details");
      const headerEl = document.getElementById("artist-rank-title");
      const genreLegendEl = document.getElementById("genre-legend");
      const legendTypeEls = Array.from(document.querySelectorAll(".legend-item[data-type]"));
      const genreLegendItems = new Map();
      const kpiWorksEl = document.getElementById("kpi-works");
      const kpiArtistsEl = document.getElementById("kpi-artists");
      const kpiTopGenreEl = document.getElementById("kpi-top-genre");
      const kpiTopArtistEl = document.getElementById("kpi-top-artist");

      const genreValueMap = new Map(
        allNodes
          .filter((node) => node.category === 1)
          .map((node) => [node.name, node.value || 0])
      );

      const escapeHtml = (value) =>
        String(value)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#39;");

      const escapeSelector = (value) => {
        if (window.CSS && CSS.escape) {
          return CSS.escape(value);
        }
        return String(value).replace(/"/g, '\\"');
      };

      const buildRankingData = (genres) => {
        if (!genres || genres.size === 0) {
          return artistRanking;
        }
        return artistRanking
          .map((artist) => {
            const counts = artistGenreCounts[artist.name] || {};
            let total = 0;
            genres.forEach((genre) => {
              total += counts[genre] || 0;
            });
            return { name: artist.name, count: total };
          })
          .filter((d) => d.count > 0)
          .sort((a, b) => b.count - a.count || a.name.localeCompare(b.name));
      };

      const renderArtistList = (data) => {
        if (!listEl) return;
        listEl.innerHTML = data
          .map(
            (artist) =>
              `<li data-artist="${escapeHtml(artist.name)}"><button data-artist="${escapeHtml(
                artist.name
              )}">${escapeHtml(artist.name)}</button> (${artist.count})</li>`
          )
          .join("");
      };

      const highlightListItem = (name, scrollIntoView = false) => {
        if (!listEl) return;
        const items = listEl.querySelectorAll("li");
        items.forEach((li) => {
          if (name && li.dataset.artist === name) {
            li.classList.add("active");
          } else {
            li.classList.remove("active");
          }
        });
        if (name && scrollIntoView) {
          const safeName = escapeSelector(name);
          const target = listEl.querySelector(`li[data-artist="${safeName}"]`);
          if (target) {
            const listRect = listEl.getBoundingClientRect();
            const itemRect = target.getBoundingClientRect();
            const offset = itemRect.top - listRect.top;
            const centerOffset = listEl.clientHeight / 2 - itemRect.height / 2;
            listEl.scrollTop += offset - centerOffset;
          }
        }
      };

      let currentVisibleArtists = new Set();

      const applyBarZoomToList = () => {
        if (!currentRanking.length) {
          renderArtistList([]);
          if (headerEl) headerEl.textContent = "Artist ranking (0)";
          currentVisibleArtists = new Set();
          currentVisibleRanking = [];
          updateKpis(selectedGenres, currentRanking);
          return;
        }
        const option = barChart.getOption();
        const zoom = option.dataZoom && option.dataZoom[0];
        let startIdx = 0;
        let endIdx = currentRanking.length - 1;
        if (zoom) {
          const resolveIndex = (val, fallback) => {
            if (val === undefined || val === null) return fallback;
            if (typeof val === "number") return Math.round(val);
            const idx = currentRankingNames.indexOf(val);
            return idx >= 0 ? idx : fallback;
          };
          startIdx = resolveIndex(zoom.startValue, startIdx);
          endIdx = resolveIndex(zoom.endValue, endIdx);
          if (endIdx < startIdx) {
            const tmp = startIdx;
            startIdx = endIdx;
            endIdx = tmp;
          }
        }
        const subset = currentRanking.slice(startIdx, endIdx + 1);
        currentVisibleRanking = subset;
        renderArtistList(subset);
        currentVisibleArtists = new Set(subset.map((d) => d.name));
        updateGraphFromFilters();
        if (headerEl) headerEl.textContent = `Artist ranking (${subset.length})`;
        updateKpis(selectedGenres, currentRanking);
      };

      const renderArtistDetails = (name) => {
        if (!detailEl) return;
        if (!name || !artistDetails[name]) {
          detailEl.innerHTML = "<em>Select an artist to see full credits.</em>";
          return;
        }
        const entries = artistDetails[name] || [];
        const total = artistTotals[name] || entries.length;
        const rows = entries
          .map(
            (entry) =>
              `<div class="detail-row"><strong>${escapeHtml(
                entry.genre
              )}</strong>: \"${escapeHtml(entry.title)}\" – ${escapeHtml(entry.role)}</div>`
          )
          .join("");
        detailEl.innerHTML = `<h4>${escapeHtml(name)}</h4><div class="hint">Total roles: ${total}</div>${rows}`;
      };

      const updateGraphFromFilters = () => {
        const genres = selectedGenres;
        if (!genres || genres.size === 0) {
          currentNodes = allNodes.filter((node) => {
            if (node.category !== 2) return true;
            if (!currentVisibleArtists || currentVisibleArtists.size === 0) return true;
            return currentVisibleArtists.has(node.name);
          });
          currentLinks = allLinks.filter((link) => {
            if (!currentVisibleArtists || currentVisibleArtists.size === 0) return true;
            if (link.source === "Oceanus Folk") return true;
            return currentVisibleArtists.has(link.target);
          });
        } else {
          const allowedArtists = new Set();
          Object.entries(artistGenreCounts).forEach(([artist, counts]) => {
            let total = 0;
            genres.forEach((genre) => {
              total += counts[genre] || 0;
            });
            if (total > 0) {
              allowedArtists.add(artist);
            }
          });
          let filteredArtists = allowedArtists;
          if (currentVisibleArtists && currentVisibleArtists.size > 0) {
            filteredArtists = new Set();
            allowedArtists.forEach((artist) => {
              if (currentVisibleArtists.has(artist)) {
                filteredArtists.add(artist);
              }
            });
          }
          currentNodes = allNodes.filter(
            (node) =>
              node.name === "Oceanus Folk" ||
              genres.has(node.name) ||
              filteredArtists.has(node.name)
          );
          currentLinks = allLinks.filter(
            (link) =>
              (link.source === "Oceanus Folk" && genres.has(link.target)) ||
              (genres.has(link.source) && filteredArtists.has(link.target))
          );
        }
        chart.setOption({
          series: [
            {
              data: currentNodes,
              links: currentLinks
            }
          ]
        });
      };

      const updateLegendHighlight = () => {
        genreLegendItems.forEach((el, name) => {
          if (selectedGenres && selectedGenres.has(name)) {
            el.classList.add("active");
          } else {
            el.classList.remove("active");
          }
        });
      };

      const updateGraph = () => {
        updateBarChart(selectedGenres);
        updateLegendHighlight();
      };

      const focusArtist = (name) => {
        if (!name) return;
        let idx = currentNodes.findIndex((node) => node.name === name);
        if (idx < 0) {
          selectedGenres.clear();
          updateGraph();
          idx = currentNodes.findIndex((node) => node.name === name);
        }
        if (idx < 0) return;
        const seriesModel = chart.getModel().getSeriesByIndex(0);
        const data = seriesModel && seriesModel.getData ? seriesModel.getData() : null;
        if (data) {
          const layout = data.getItemLayout(idx);
          if (layout && layout.x !== undefined && layout.y !== undefined) {
            const width = chart.getWidth();
            const height = chart.getHeight();
            const margin = 80;
            if (
              layout.x < margin ||
              layout.x > width - margin ||
              layout.y < margin ||
              layout.y > height - margin
            ) {
              chart.dispatchAction({
                type: "graphRoam",
                dx: width / 2 - layout.x,
                dy: height / 2 - layout.y
              });
            }
          }
        }
        chart.dispatchAction({
          type: "highlight",
          seriesIndex: 0,
          dataIndex: idx
        });
        chart.dispatchAction({
          type: "showTip",
          seriesIndex: 0,
          dataIndex: idx
        });
        highlightListItem(name, true);
        renderArtistDetails(name);
      };

      const updateBarChart = (genres) => {
        const data = buildRankingData(genres);
        currentRanking = data;
        currentRankingNames = data.map((d) => d.name);
        const names = currentRankingNames;
        const values = data.map((d) => d.count);

        const barOption = {
          backgroundColor: "transparent",
          grid: { left: 10, right: 18, top: 12, bottom: 30 },
          xAxis: {
            type: "value",
            axisLabel: { color: "#0f172a", fontSize: 10, margin: 6 },
            axisLine: { show: true, lineStyle: { color: "#cbd5e1" } },
            axisTick: { show: true },
            splitLine: { lineStyle: { color: "#e2e8f0" } },
            name: "Role count",
            nameLocation: "middle",
            nameGap: 22,
            nameTextStyle: {
              color: "#64748b",
              fontSize: 11,
              fontFamily: "Space Grotesk"
            }
          },
          yAxis: {
            type: "category",
            data: names,
            inverse: true,
            axisLabel: { show: false },
            axisTick: { show: false },
            axisLine: { show: false }
          },
          dataZoom: [
            {
              type: "slider",
              yAxisIndex: 0,
              right: 6,
              startValue: 0,
              endValue: Math.max(0, names.length - 1)
            },
            {
              type: "inside",
              yAxisIndex: 0
            }
          ],
          series: [
            {
              type: "bar",
              data: values,
              itemStyle: { color: "#2563eb" },
              label: { show: false },
              barWidth: 10
            }
          ]
        };

        barChart.setOption(barOption, true);
        barChart.resize();
        applyBarZoomToList();
      };

      const updateKpis = (genres, rankingData) => {
        if (!kpiWorksEl || !kpiArtistsEl || !kpiTopGenreEl || !kpiTopArtistEl) {
          return;
        }
        const visibleRanking = currentVisibleRanking.length
          ? currentVisibleRanking
          : rankingData;
        if (!genres || genres.size === 0) {
          kpiWorksEl.textContent = kpiDefault.works ?? "";
          kpiArtistsEl.textContent = visibleRanking.length
            ? visibleRanking.length.toLocaleString()
            : kpiDefault.artists ?? "";
          kpiTopGenreEl.textContent = kpiDefault.topGenre ?? "";
          if (visibleRanking.length) {
            kpiTopArtistEl.textContent = `${visibleRanking[0].name} (${visibleRanking[0].count})`;
          } else {
            kpiTopArtistEl.textContent = kpiDefault.topArtist ?? "";
          }
          return;
        }
        let worksTotal = 0;
        let topGenre = null;
        let topGenreCount = 0;
        genres.forEach((genre) => {
          const val = genreValueMap.get(genre) || 0;
          worksTotal += val;
          if (val > topGenreCount) {
            topGenreCount = val;
            topGenre = genre;
          }
        });
        const topArtist =
          visibleRanking && visibleRanking.length ? visibleRanking[0] : null;
        kpiWorksEl.textContent = worksTotal.toLocaleString();
        kpiArtistsEl.textContent = visibleRanking.length.toLocaleString();
        kpiTopGenreEl.textContent = topGenre ? `${topGenre} (${topGenreCount})` : "—";
        kpiTopArtistEl.textContent = topArtist ? `${topArtist.name} (${topArtist.count})` : "—";
      };

      if (listEl) {
        listEl.addEventListener("click", (event) => {
          const target = event.target;
          if (!target.dataset || !target.dataset.artist) {
            return;
          }
          const name = target.dataset.artist;
          focusArtist(name);
        });
      }

      chart.on("click", (params) => {
        if (params.dataType !== "node") return;
        const node = params.data;
        if (node.category === 1) {
          const shiftHeld = Boolean(
            params.event && params.event.event && params.event.event.shiftKey
          );
          if (shiftHeld) {
            if (selectedGenres.has(node.name)) {
              selectedGenres.delete(node.name);
            } else {
              selectedGenres.add(node.name);
            }
          } else {
            if (selectedGenres.size === 1 && selectedGenres.has(node.name)) {
              selectedGenres.clear();
            } else {
              selectedGenres = new Set([node.name]);
            }
          }
          updateGraph();
          return;
        }
        if (node.category === 2) {
          focusArtist(node.name);
        } else {
          selectedGenres.clear();
          updateGraph();
        }
      });

      chart.on("contextmenu", (params) => {
        if (params.dataType !== "node") return;
        const node = params.data;
        if (node.category !== 1) return;
        if (params.event && params.event.event) {
          params.event.event.preventDefault();
        }
        const shiftHeld = Boolean(
          params.event && params.event.event && params.event.event.shiftKey
        );
        if (!shiftHeld) return;
        if (selectedGenres.has(node.name)) {
          selectedGenres.delete(node.name);
        } else {
          selectedGenres.add(node.name);
        }
        updateGraph();
      });

      chart.getZr().on("click", (event) => {
        if (!event.target) {
          selectedGenres.clear();
          updateGraph();
        }
      });

      const buildGenreLegend = () => {
        if (!genreLegendEl) return;
        const genres = allNodes
          .filter((node) => node.category === 1)
          .sort((a, b) => a.name.localeCompare(b.name));
        genreLegendEl.innerHTML = "";
        genreLegendItems.clear();
        genres.forEach((node) => {
          const item = document.createElement("div");
          item.className = "legend-item legend-genre";
          item.dataset.genre = node.name;
          const swatch = document.createElement("span");
          swatch.className = "legend-swatch legend-diamond";
          const color = node.itemStyle && node.itemStyle.color ? node.itemStyle.color : "#94a3b8";
          swatch.style.background = color;
          item.appendChild(swatch);
          item.appendChild(document.createTextNode(node.name));
          genreLegendEl.appendChild(item);
          genreLegendItems.set(node.name, item);
        });
      };

      const highlightNodes = (predicate) => {
        if (!predicate) return;
        chart.dispatchAction({ type: "downplay", seriesIndex: 0 });
        currentNodes.forEach((node, idx) => {
          if (predicate(node)) {
            chart.dispatchAction({ type: "highlight", seriesIndex: 0, dataIndex: idx });
          }
        });
      };

      const highlightByNames = (names) => {
        if (!names || names.size === 0) return;
        chart.dispatchAction({ type: "downplay", seriesIndex: 0 });
        currentNodes.forEach((node, idx) => {
          if (names.has(node.name)) {
            chart.dispatchAction({ type: "highlight", seriesIndex: 0, dataIndex: idx });
          }
        });
      };

      const applyLegendHighlight = (predicate, names = null) => {
        let highlightNames = names ? new Set(names) : null;
        if (!highlightNames && predicate) {
          highlightNames = new Set(
            currentNodes.filter((node) => predicate(node)).map((node) => node.name)
          );
        }
        const nextNodes = currentNodes.map((node) => {
          const isMatch = highlightNames
            ? highlightNames.has(node.name)
            : predicate
            ? predicate(node)
            : false;
          const baseStyle = node.itemStyle || {};
          return {
            ...node,
            itemStyle: {
              ...baseStyle,
              opacity: isMatch ? 1 : 0.2
            },
            label: {
              ...(node.label || {}),
              color: isMatch ? (node.label && node.label.color ? node.label.color : "#0f172a") : "#94a3b8"
            }
          };
        });
        const nextLinks = currentLinks.map((link) => {
          const isMatch =
            highlightNames &&
            (highlightNames.has(link.source) || highlightNames.has(link.target));
          const baseStyle = link.lineStyle || {};
          return {
            ...link,
            lineStyle: {
              ...baseStyle,
              opacity: isMatch ? Math.max(baseStyle.opacity || 0.6, 0.6) : 0.08
            }
          };
        });
        chart.setOption({
          series: [
            {
              data: nextNodes,
              links: nextLinks
            }
          ]
        });
      };

      const clearHighlight = () => {
        chart.dispatchAction({ type: "downplay", seriesIndex: 0 });
        chart.setOption({
          series: [
            {
              data: currentNodes,
              links: currentLinks
            }
          ]
        });
      };

      const applyGenreSelection = (genre, additive) => {
        if (!genre) return;
        if (additive) {
          if (selectedGenres.has(genre)) {
            selectedGenres.delete(genre);
          } else {
            selectedGenres.add(genre);
          }
        } else {
          if (selectedGenres.size === 1 && selectedGenres.has(genre)) {
            selectedGenres.clear();
          } else {
            selectedGenres = new Set([genre]);
          }
        }
        updateGraph();
      };

      if (genreLegendEl) {
        genreLegendEl.addEventListener("click", (event) => {
          const item = event.target.closest(".legend-item.legend-genre");
          if (!item || !genreLegendEl.contains(item)) return;
          const genre = item.dataset.genre;
          applyGenreSelection(genre, event.shiftKey);
        });

        genreLegendEl.addEventListener("contextmenu", (event) => {
          const item = event.target.closest(".legend-item.legend-genre");
          if (!item || !genreLegendEl.contains(item)) return;
          event.preventDefault();
          if (!event.shiftKey) return;
          const genre = item.dataset.genre;
          applyGenreSelection(genre, true);
        });

        genreLegendEl.addEventListener("mouseover", (event) => {
          const item = event.target.closest(".legend-item.legend-genre");
          if (!item || !genreLegendEl.contains(item)) return;
          item.classList.add("is-hover");
          const genre = item.dataset.genre;
          const names = new Set([genre]);
          currentLinks.forEach((link) => {
            if (link.source === genre) {
              names.add(link.target);
            }
          });
          applyLegendHighlight(null, names);
        });

        genreLegendEl.addEventListener("mouseout", (event) => {
          const item = event.target.closest(".legend-item.legend-genre");
          if (!item || !genreLegendEl.contains(item)) return;
          if (item.contains(event.relatedTarget)) return;
          item.classList.remove("is-hover");
          clearHighlight();
        });
      }

      legendTypeEls.forEach((item) => {
        item.addEventListener("mouseenter", () => {
          item.classList.add("is-hover");
          const type = item.dataset.type;
          if (type === "oceanus") {
            applyLegendHighlight((node) => node.category === 0);
          } else if (type === "genre") {
            applyLegendHighlight((node) => node.category === 1);
          } else if (type === "artist") {
            applyLegendHighlight((node) => node.category === 2);
          }
        });
        item.addEventListener("mouseleave", () => {
          item.classList.remove("is-hover");
          clearHighlight();
        });
      });

      barChart.on("click", (params) => {
        if (!params.name) return;
        focusArtist(params.name);
      });

      barChart.on("dataZoom", () => {
        applyBarZoomToList();
      });

      barChart.on("mouseover", (params) => {
        if (!params.name) return;
        highlightListItem(params.name, true);
        const idx = currentNodes.findIndex((node) => node.name === params.name);
        if (idx >= 0) {
          chart.dispatchAction({ type: "highlight", seriesIndex: 0, dataIndex: idx });
        }
      });

      barChart.on("mouseout", () => {
        highlightListItem(null);
        chart.dispatchAction({ type: "downplay", seriesIndex: 0 });
      });

      chart.on("mouseover", (params) => {
        if (params.dataType !== "node" || params.data.category !== 2) return;
        highlightListItem(params.data.name, true);
      });

      chart.on("mouseout", (params) => {
        if (params.dataType !== "node" || params.data.category !== 2) return;
        highlightListItem(null);
      });

      buildGenreLegend();
      updateGraph();
      window.addEventListener("resize", () => {
        chart.resize();
        barChart.resize();
      });
    </script>
  </body>
</html>
